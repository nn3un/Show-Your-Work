import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;

import java.io.File;
import java.io.FileReader;
import java.util.Scanner;

public class CSVFileReader {
    /**
     * Helper method that generates a version of the original from the current log file
     * @param csvFilePath Path of the log file
     * @return The version of the original generated by following the csv log
     */
	public static String generateFileFromCsv(String csvFilePath)
	{
	    StringBuilder content = new StringBuilder();
	    content.append(" ");
		try {
			File csvData = new File(csvFilePath);
			//CSVParser to parse the csvfile (https://commons.apache.org/proper/commons-csv/apidocs/index.html)
			CSVParser parser = CSVParser.parse(new FileReader(csvData), CSVFormat.DEFAULT);
			for (CSVRecord csvRecord : parser) {
				Long ms = Long.parseLong(csvRecord.get(0));
				String type = csvRecord.get(1);
				int offset = Integer.parseInt(csvRecord.get(2));
				String toChange = csvRecord.get(3);
				//If the type is add get the portion of the string starting from index 0 to offset add the new string, and then add the leftover
				if (type.equals("add")) {
					content.insert(offset, toChange);
				}
				//If the type is sub then just skip over the portion of the string by manipulating index
				else if (type.equals("sub")) {
					//TODO: If memory becomes an issue, consider only saving the length of the substring when the type is "sub" since the actual deleted string is useless
					content.delete(offset, offset+toChange.length());
				}
			}
		}
		catch (Exception e) {
		    //Todo: Better Error Handling
			e.printStackTrace();
		}
        return content.toString();
	}
}